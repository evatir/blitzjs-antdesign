import { log } from '@blitzjs/display';
import { Box, useInput, Text, useApp, render } from 'ink';
import React, { createElement, useState, useCallback, useEffect, Fragment, useRef, useMemo } from 'react';
import { spawn } from 'cross-spawn';
import { existsSync, readFileSync, writeFileSync } from 'fs-extra';
import Spinner from 'ink-spinner';
import { resolve } from 'path';
import { createPatch } from 'diff';
import j from 'jscodeshift';
import getBabelOptions from 'recast/parsers/_babel_options';
import { parser } from 'recast/parsers/babel';
import { prompt } from 'enquirer';
import globby from 'globby';
import { Generator } from '@blitzjs/generator';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var Newline = function Newline(_ref) {
  var _ref$count = _ref.count,
      count = _ref$count === void 0 ? 1 : _ref$count;
  return /*#__PURE__*/createElement(Box, {
    paddingBottom: count
  });
};

function useEnterToContinue(cb, additionalCondition) {
  if (additionalCondition === void 0) {
    additionalCondition = true;
  }

  useInput(function (_input, key) {
    if (additionalCondition && key["return"]) {
      cb();
    }
  });
}

function isDynamicExecutorArgument(input) {
  return typeof input === "function";
}

function Frontmatter(_ref) {
  var executor = _ref.executor;
  var lineLength = executor.stepName.length + 6;
  var verticalBorder = "+" + new Array(lineLength).fill("â€“").join("") + "+";
  return /*#__PURE__*/createElement(Box, {
    flexDirection: "column",
    paddingBottom: 1
  }, /*#__PURE__*/createElement(Newline, null), /*#__PURE__*/createElement(Box, {
    flexDirection: "column"
  }, /*#__PURE__*/createElement(Text, {
    color: "#8a3df0",
    bold: true
  }, verticalBorder), /*#__PURE__*/createElement(Text, {
    color: "#8a3df0",
    bold: true
  }, "\u23AA\xA0\xA0\xA0", executor.stepName, "\xA0\xA0\xA0\u23AA"), /*#__PURE__*/createElement(Text, {
    color: "#8a3df0",
    bold: true
  }, verticalBorder)), /*#__PURE__*/createElement(Text, {
    color: "gray",
    italic: true
  }, executor.explanation));
}
function getExecutorArgument(input, cliArgs) {
  if (isDynamicExecutorArgument(input)) {
    return input(cliArgs);
  }

  return input;
}

function isAddDependencyExecutor(executor) {
  return executor.packages !== undefined;
}
var type$2 = "add-dependency";

function Package(_ref) {
  var pkg = _ref.pkg,
      loading = _ref.loading;
  return /*#__PURE__*/createElement(Text, null, "   ", loading ? /*#__PURE__*/createElement(Spinner, null) : "ðŸ“¦", " " + pkg.name + "@" + pkg.version);
}

var DependencyList = function DependencyList(_ref2) {
  var lede = _ref2.lede,
      _ref2$depsLoading = _ref2.depsLoading,
      depsLoading = _ref2$depsLoading === void 0 ? false : _ref2$depsLoading,
      _ref2$devDepsLoading = _ref2.devDepsLoading,
      devDepsLoading = _ref2$devDepsLoading === void 0 ? false : _ref2$devDepsLoading,
      packages = _ref2.packages;
  var prodPackages = packages.filter(function (p) {
    return !p.isDevDep;
  });
  var devPackages = packages.filter(function (p) {
    return p.isDevDep;
  });
  return /*#__PURE__*/createElement(Box, {
    flexDirection: "column"
  }, /*#__PURE__*/createElement(Text, null, lede), /*#__PURE__*/createElement(Newline, null), prodPackages.length ? /*#__PURE__*/createElement(Text, null, "Dependencies to be installed:") : null, prodPackages.map(function (pkg) {
    return /*#__PURE__*/createElement(Package, {
      key: pkg.name,
      pkg: pkg,
      loading: depsLoading
    });
  }), /*#__PURE__*/createElement(Newline, null), devPackages.length ? /*#__PURE__*/createElement(Text, null, "Dev Dependencies to be installed:") : null, devPackages.map(function (pkg) {
    return /*#__PURE__*/createElement(Package, {
      key: pkg.name,
      pkg: pkg,
      loading: devDepsLoading
    });
  }));
};
/**
 * Exported for unit testing purposes
 */


function getPackageManager() {
  if (existsSync(resolve("yarn.lock"))) {
    return "yarn";
  }

  return "npm";
}
/**
 * Exported for unit testing purposes
 */

async function installPackages(packages, isDev) {
  if (isDev === void 0) {
    isDev = false;
  }

  var packageManager = getPackageManager();
  var isNPM = packageManager === "npm";
  var pkgInstallArg = isNPM ? "install" : "add";
  var args = [pkgInstallArg];

  if (isDev) {
    args.push(isNPM ? "--save-dev" : "-D");
  }

  packages.forEach(function (pkg) {
    pkg.version ? args.push(pkg.name + "@" + pkg.version) : args.push(pkg.name);
  });
  await new Promise(function (resolve) {
    var cp = spawn(packageManager, args, {
      stdio: ["inherit", "pipe", "pipe"]
    });
    cp.on("exit", resolve);
  });
}
var Commit$2 = function Commit(_ref3) {
  var cliArgs = _ref3.cliArgs,
      step = _ref3.step,
      onChangeCommitted = _ref3.onChangeCommitted;

  var _React$useState = useState(false),
      depsInstalled = _React$useState[0],
      setDepsInstalled = _React$useState[1];

  var _React$useState2 = useState(false),
      devDepsInstalled = _React$useState2[0],
      setDevDepsInstalled = _React$useState2[1];

  var handleChangeCommitted = useCallback(function () {
    var packages = step.packages;
    var dependencies = packages.length === 1 ? "dependency" : "dependencies";
    onChangeCommitted("Installed " + packages.length + " " + dependencies);
  }, [onChangeCommitted, step]);
  useEnterToContinue(handleChangeCommitted, depsInstalled && devDepsInstalled);
  useEffect(function () {
    async function installDeps() {
      var packagesToInstall = getExecutorArgument(step.packages, cliArgs).filter(function (p) {
        return !p.isDevDep;
      });
      await installPackages(packagesToInstall);
      setDepsInstalled(true);
    } // eslint-disable-next-line @typescript-eslint/no-floating-promises


    installDeps();
  }, [cliArgs, step]);
  useEffect(function () {
    if (!depsInstalled) return;

    async function installDevDeps() {
      var packagesToInstall = getExecutorArgument(step.packages, cliArgs).filter(function (p) {
        return p.isDevDep;
      });
      await installPackages(packagesToInstall, true);
      setDevDepsInstalled(true);
    } // eslint-disable-next-line @typescript-eslint/no-floating-promises


    installDevDeps();
  }, [cliArgs, depsInstalled, step]);
  useEffect(function () {
    if (depsInstalled && devDepsInstalled) {
      handleChangeCommitted();
    }
  }, [depsInstalled, devDepsInstalled, handleChangeCommitted]);

  if (!isAddDependencyExecutor(step)) {
    onChangeCommitted();
    return null;
  }

  return /*#__PURE__*/createElement(Fragment, null, /*#__PURE__*/createElement(DependencyList, {
    lede: "Hang tight! Installing dependencies...",
    depsLoading: !depsInstalled,
    devDepsLoading: !devDepsInstalled,
    packages: getExecutorArgument(step.packages, cliArgs)
  }));
};

var AddDependencyExecutor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isAddDependencyExecutor: isAddDependencyExecutor,
  type: type$2,
  getPackageManager: getPackageManager,
  installPackages: installPackages,
  Commit: Commit$2
});

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var customTsParser = {
  parse: function parse(source, options) {
    var babelOptions = getBabelOptions(options);
    babelOptions.plugins.push("typescript");
    babelOptions.plugins.push("jsx");
    return parser.parse(source, babelOptions);
  }
};
var TransformStatus;

(function (TransformStatus) {
  TransformStatus["Success"] = "success";
  TransformStatus["Failure"] = "failure";
})(TransformStatus || (TransformStatus = {}));

function stringProcessFile(original, transformerFn) {
  return transformerFn(original);
}
function processFile(original, transformerFn) {
  var program = j(original, {
    parser: customTsParser
  });
  return transformerFn(program).toSource();
}
function transform(processFile, targetFilePaths) {
  var results = [];

  for (var _iterator = _createForOfIteratorHelperLoose(targetFilePaths), _step; !(_step = _iterator()).done;) {
    var filePath = _step.value;

    if (!existsSync(filePath)) {
      results.push({
        status: TransformStatus.Failure,
        filename: filePath,
        error: new Error("Error: " + filePath + " not found")
      });
    }

    try {
      var fileBuffer = readFileSync(filePath);
      var fileSource = fileBuffer.toString("utf-8");
      var transformedCode = processFile(fileSource);
      writeFileSync(filePath, transformedCode);
      results.push({
        status: TransformStatus.Success,
        filename: filePath
      });
    } catch (err) {
      results.push({
        status: TransformStatus.Failure,
        filename: filePath,
        error: err
      });
    }
  }

  return results;
}

var SearchType;

(function (SearchType) {
  SearchType[SearchType["file"] = 0] = "file";
  SearchType[SearchType["directory"] = 1] = "directory";
})(SearchType || (SearchType = {}));

function getMatchingFiles(filter) {
  if (filter === void 0) {
    filter = "";
  }

  return globby(filter, {
    expandDirectories: true
  });
}

async function filePrompt(options) {
  var choices = options.getChoices ? options.getChoices(options.context) : await getMatchingFiles(options.globFilter);

  if (choices.length === 1) {
    return choices[0];
  }

  var results = await prompt({
    type: "autocomplete",
    name: "file",
    message: "Select the target file",
    // @ts-ignore
    limit: 10,
    choices: choices
  });
  return results.file;
}

function isFileTransformExecutor(executor) {
  return executor.transform !== undefined || executor.transformPlain !== undefined;
}
var type$1 = "file-transform";
var Propose = function Propose(_ref) {
  var cliArgs = _ref.cliArgs,
      onProposalAccepted = _ref.onProposalAccepted,
      step = _ref.step;

  var _React$useState = useState(null),
      diff = _React$useState[0],
      setDiff = _React$useState[1];

  var filePathRef = useRef("");
  useEnterToContinue(function () {
    return onProposalAccepted(filePathRef.current);
  }, !!filePathRef.current);
  useEffect(function () {
    async function generateDiff() {
      var fileToTransform = await filePrompt({
        context: cliArgs,
        globFilter: getExecutorArgument(step.singleFileSearch, cliArgs),
        getChoices: step.selectTargetFiles
      });
      filePathRef.current = fileToTransform;
      var originalFile = readFileSync(fileToTransform).toString("utf-8");
      var newFile = step.transformPlain ? stringProcessFile(originalFile, step.transformPlain) : processFile(originalFile, step.transform);
      return createPatch(fileToTransform, originalFile, newFile);
    } // eslint-disable-next-line @typescript-eslint/no-floating-promises


    generateDiff().then(setDiff);
  }, [cliArgs, step]);

  if (!diff) {
    return /*#__PURE__*/createElement(Box, null, /*#__PURE__*/createElement(Text, null, /*#__PURE__*/createElement(Spinner, null), "Generating file diff..."));
  }

  return /*#__PURE__*/createElement(Box, {
    flexDirection: "column"
  }, diff.split("\n").slice(2).map(function (line, idx) {
    var styleProps = {};

    if (line.startsWith("-") && !line.startsWith("---")) {
      styleProps.bold = true;
      styleProps.color = "red";
    } else if (line.startsWith("+") && !line.startsWith("+++")) {
      styleProps.bold = true;
      styleProps.color = "green";
    }

    return /*#__PURE__*/createElement(Text, _extends({}, styleProps, {
      key: idx
    }), line);
  }), /*#__PURE__*/createElement(Newline, null), /*#__PURE__*/createElement(Text, {
    bold: true
  }, "The above changes will be made. Press ENTER to continue"));
};
var Commit$1 = function Commit(_ref2) {
  var onChangeCommitted = _ref2.onChangeCommitted,
      filePath = _ref2.proposalData,
      step = _ref2.step;

  var _React$useState2 = useState(true),
      loading = _React$useState2[0],
      setLoading = _React$useState2[1];

  useEffect(function () {
    var results = transform(function (original) {
      return step.transformPlain ? stringProcessFile(original, step.transformPlain) : processFile(original, step.transform);
    }, [filePath]);

    if (results.some(function (r) {
      return r.status === TransformStatus.Failure;
    })) {
      console.error(results);
    }

    setLoading(false);
  }, [filePath, step]);

  if (loading) {
    return /*#__PURE__*/createElement(Box, null, /*#__PURE__*/createElement(Spinner, null), /*#__PURE__*/createElement(Text, null, "Applying file changes"));
  }

  onChangeCommitted("Modified file: " + filePath);
  return null;
};

var FileTransformExecutor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isFileTransformExecutor: isFileTransformExecutor,
  type: type$1,
  Propose: Propose,
  Commit: Commit$1
});

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function isNewFileExecutor(executor) {
  return executor.templatePath !== undefined;
}
var type = "new-file";

var TempGenerator = /*#__PURE__*/function (_Generator) {
  _inheritsLoose(TempGenerator, _Generator);

  function TempGenerator(options) {
    var _this;

    _this = _Generator.call(this, options) || this;
    _this.sourceRoot = void 0;
    _this.targetDirectory = void 0;
    _this.templateValues = void 0;
    _this.returnResults = true;
    _this.sourceRoot = {
      type: "absolute",
      path: options.templateRoot
    };
    _this.templateValues = options.templateValues;
    _this.targetDirectory = options.targetDirectory || ".";
    return _this;
  }

  var _proto = TempGenerator.prototype;

  _proto.getTemplateValues = function getTemplateValues() {
    return this.templateValues;
  };

  _proto.getTargetDirectory = function getTargetDirectory() {
    return this.targetDirectory;
  };

  return TempGenerator;
}(Generator);

var Commit = function Commit(_ref) {
  var cliArgs = _ref.cliArgs,
      onChangeCommitted = _ref.onChangeCommitted,
      step = _ref.step;
  var generatorArgs = useMemo(function () {
    return {
      destinationRoot: ".",
      targetDirectory: getExecutorArgument(step.targetDirectory, cliArgs),
      templateRoot: getExecutorArgument(step.templatePath, cliArgs),
      templateValues: getExecutorArgument(step.templateValues, cliArgs)
    };
  }, [cliArgs, step]);

  var _useState = useState(""),
      fileCreateOutput = _useState[0],
      setFileCreateOutput = _useState[1];

  var fileCreateLines = fileCreateOutput.split("\n");
  var handleChangeCommitted = useCallback(function () {
    onChangeCommitted("Successfully created " + fileCreateLines.map(function (l) {
      return l.split(" ").slice(1).join("").trim();
    }).join(", "));
  }, [fileCreateLines, onChangeCommitted]);
  useEnterToContinue(handleChangeCommitted);
  useEffect(function () {
    async function createNewFiles() {
      if (!fileCreateOutput) {
        var generator = new TempGenerator(generatorArgs);
        var results = await generator.run();
        setFileCreateOutput(results);
      }
    } // eslint-disable-next-line @typescript-eslint/no-floating-promises


    createNewFiles();
  }, [fileCreateOutput, generatorArgs]);
  return /*#__PURE__*/createElement(Box, {
    flexDirection: "column"
  }, fileCreateOutput ? /*#__PURE__*/createElement(Fragment, null, fileCreateOutput ? /*#__PURE__*/createElement(Text, null, fileCreateOutput) : null, /*#__PURE__*/createElement(Newline, null), /*#__PURE__*/createElement(Text, {
    bold: true
  }, "Press ENTER to continue")) : null);
};

var NewFileExecutor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isNewFileExecutor: isNewFileExecutor,
  type: type,
  Commit: Commit
});

var _ExecutorMap;
var Action;

(function (Action) {
  Action[Action["SkipStep"] = 0] = "SkipStep";
  Action[Action["ProposeChange"] = 1] = "ProposeChange";
  Action[Action["ApplyChange"] = 2] = "ApplyChange";
  Action[Action["CommitApproved"] = 3] = "CommitApproved";
  Action[Action["CompleteChange"] = 4] = "CompleteChange";
})(Action || (Action = {}));

var Status;

(function (Status) {
  Status[Status["Pending"] = 0] = "Pending";
  Status[Status["Proposed"] = 1] = "Proposed";
  Status[Status["ReadyToCommit"] = 2] = "ReadyToCommit";
  Status[Status["Committing"] = 3] = "Committing";
  Status[Status["Committed"] = 4] = "Committed";
})(Status || (Status = {}));

var ExecutorMap = (_ExecutorMap = {}, _ExecutorMap[type$2] = AddDependencyExecutor, _ExecutorMap[type] = NewFileExecutor, _ExecutorMap[type$1] = FileTransformExecutor, _ExecutorMap);
var initialState = {
  steps: [],
  current: -1
};

function recipeReducer(state, action) {
  if (state === void 0) {
    state = initialState;
  }

  var newState = _extends({}, state);

  switch (action.type) {
    case Action.ProposeChange:
      newState.steps[newState.current].status = Status.Proposed;
      break;

    case Action.CommitApproved:
      newState.steps[newState.current].status = Status.ReadyToCommit;
      newState.steps[newState.current].proposalData = action.data;
      break;

    case Action.ApplyChange:
      newState.steps[newState.current].status = Status.Committing;
      break;

    case Action.CompleteChange:
      newState.steps[newState.current].status = Status.Committed;
      newState.steps[newState.current].successMsg = action.data;
      newState.current = Math.min(newState.current + 1, newState.steps.length - 1);
      break;

    case Action.SkipStep:
      newState.current += 1;
      break;
  }

  return newState;
}

var DispatchContext = /*#__PURE__*/React.createContext(function () {});

function WelcomeMessage(_ref) {
  var recipeMeta = _ref.recipeMeta;
  return /*#__PURE__*/React.createElement(Box, {
    flexDirection: "column"
  }, /*#__PURE__*/React.createElement(Text, {
    color: "#8a3df0",
    bold: true
  }, "Recipe: ", recipeMeta.name), /*#__PURE__*/React.createElement(Newline, null), /*#__PURE__*/React.createElement(Text, {
    color: "gray"
  }, /*#__PURE__*/React.createElement(Text, {
    italic: true
  }, recipeMeta.description)), /*#__PURE__*/React.createElement(Newline, null), /*#__PURE__*/React.createElement(Text, {
    color: "gray"
  }, "Repo: ", /*#__PURE__*/React.createElement(Text, {
    italic: true
  }, recipeMeta.repoLink)), /*#__PURE__*/React.createElement(Text, {
    color: "gray"
  }, "Author: ", /*#__PURE__*/React.createElement(Text, {
    italic: true
  }, recipeMeta.owner)), /*#__PURE__*/React.createElement(Newline, null), /*#__PURE__*/React.createElement(Text, {
    bold: true
  }, "Press ENTER to continue"));
}

function StepExecutor(_ref2) {
  var cliArgs = _ref2.cliArgs,
      proposalData = _ref2.proposalData,
      step = _ref2.step,
      status = _ref2.status;
  var _ExecutorMap$step$ste = ExecutorMap[step.stepType],
      Propose = _ExecutorMap$step$ste.Propose,
      Commit = _ExecutorMap$step$ste.Commit;
  var dispatch = React.useContext(DispatchContext);
  var handleProposalAccepted = React.useCallback(function (msg) {
    dispatch({
      type: Action.CommitApproved,
      data: msg
    });
  }, [dispatch]);
  var handleChangeCommitted = React.useCallback(function (msg) {
    dispatch({
      type: Action.CompleteChange,
      data: msg
    });
  }, [dispatch]);
  React.useEffect(function () {
    if (status === Status.Pending) {
      dispatch({
        type: Action.ProposeChange
      });
    } else if (status === Status.ReadyToCommit) {
      dispatch({
        type: Action.ApplyChange
      });
    }

    if (status === Status.Proposed && !Propose) {
      dispatch({
        type: Action.CommitApproved
      });
    }
  }, [dispatch, status, Propose]);
  return /*#__PURE__*/React.createElement(Box, {
    flexDirection: "column"
  }, status !== Status.Committed ? /*#__PURE__*/React.createElement(Frontmatter, {
    executor: step
  }) : null, [Status.Proposed].includes(status) && Propose ? /*#__PURE__*/React.createElement(Propose, {
    cliArgs: cliArgs,
    step: step,
    onProposalAccepted: handleProposalAccepted
  }) : null, [Status.Committing].includes(status) ? /*#__PURE__*/React.createElement(Commit, {
    cliArgs: cliArgs,
    proposalData: proposalData,
    step: step,
    onChangeCommitted: handleChangeCommitted
  }) : null);
}

function RecipeRenderer(_ref3) {
  var _state$steps$state$cu, _state$steps$state$cu2, _state$steps$state$cu3;

  var cliArgs = _ref3.cliArgs,
      steps = _ref3.steps,
      recipeMeta = _ref3.recipeMeta;

  var _useApp = useApp(),
      exit = _useApp.exit;

  var _React$useReducer = React.useReducer(recipeReducer, _extends({}, initialState, {
    steps: steps.map(function (e) {
      return {
        executor: e,
        status: Status.Pending,
        successMsg: ""
      };
    })
  })),
      state = _React$useReducer[0],
      dispatch = _React$useReducer[1];

  useInput(function (input, key) {
    if (input === "c" && key.ctrl) {
      exit(new Error("You aborted installation"));
      return;
    }
  });
  useEnterToContinue(function () {
    return dispatch({
      type: Action.SkipStep
    });
  }, state.current === -1);
  React.useEffect(function () {
    if (state.current === state.steps.length - 1 && state.steps[state.current].status === Status.Committed) {
      exit();
    }
  });
  var messages = state.steps.map(function (step) {
    return step.successMsg;
  }).filter(function (s) {
    return s;
  });
  return /*#__PURE__*/React.createElement(DispatchContext.Provider, {
    value: dispatch
  }, messages.map(function (msg, index) {
    return /*#__PURE__*/React.createElement(Text, {
      key: msg + index,
      color: "green"
    }, msg === "\n" ? "" : "âœ…", " ", msg);
  }), state.current === -1 ? /*#__PURE__*/React.createElement(WelcomeMessage, {
    recipeMeta: recipeMeta
  }) : null, state.current > -1 ? /*#__PURE__*/React.createElement(StepExecutor, {
    cliArgs: cliArgs,
    proposalData: (_state$steps$state$cu = state.steps[state.current]) == null ? void 0 : _state$steps$state$cu.proposalData,
    step: (_state$steps$state$cu2 = state.steps[state.current]) == null ? void 0 : _state$steps$state$cu2.executor,
    status: (_state$steps$state$cu3 = state.steps[state.current]) == null ? void 0 : _state$steps$state$cu3.status
  }) : null);
}

var RecipeExecutor = /*#__PURE__*/function () {
  function RecipeExecutor(options, steps) {
    this.steps = void 0;
    this.options = void 0;
    this.options = options;
    this.steps = steps;
  }

  var _proto = RecipeExecutor.prototype;

  _proto.run = async function run(cliArgs) {
    try {
      var _render = render( /*#__PURE__*/React.createElement(RecipeRenderer, {
        cliArgs: cliArgs,
        steps: this.steps,
        recipeMeta: this.options
      }), {
        exitOnCtrlC: false
      }),
          waitUntilExit = _render.waitUntilExit;

      await waitUntilExit();
      log.info("\n\uD83C\uDF89 The " + this.options.name + " recipe has been installed!\n");
    } catch (e) {
      log.error(e);
      return;
    }
  };

  return RecipeExecutor;
}();

function RecipeBuilder() {
  var steps = [];
  var meta = {};
  return {
    setName: function setName(name) {
      meta.name = name;
      return this;
    },
    setDescription: function setDescription(description) {
      meta.description = description;
      return this;
    },
    setOwner: function setOwner(owner) {
      meta.owner = owner;
      return this;
    },
    setRepoLink: function setRepoLink(repoLink) {
      meta.repoLink = repoLink;
      return this;
    },
    addAddDependenciesStep: function addAddDependenciesStep(step) {
      steps.push(_extends({
        stepType: type$2
      }, step));
      return this;
    },
    addNewFilesStep: function addNewFilesStep(step) {
      steps.push(_extends({
        stepType: type
      }, step));
      return this;
    },
    addTransformFilesStep: function addTransformFilesStep(step) {
      steps.push(_extends({
        stepType: type$1
      }, step));
      return this;
    },
    build: function build() {
      return new RecipeExecutor(meta, steps);
    }
  };
}

function ext(jsx) {
  if (jsx === void 0) {
    jsx = false;
  }

  return existsSync(resolve("tsconfig.json")) ? jsx ? ".tsx" : ".ts" : ".js";
}

var paths = {
  document: function document() {
    return "app/pages/_document" + ext(true);
  },
  app: function app() {
    return "app/pages/_app" + ext(true);
  },
  entry: function entry() {
    return "app/pages/index" + ext(true);
  },
  babelConfig: function babelConfig() {
    return "babel.config.js";
  },
  blitzConfig: function blitzConfig() {
    return "blitz.config.js";
  },
  packageJson: function packageJson() {
    return "package.json";
  },
  prismaSchema: function prismaSchema() {
    return "db/schema.prisma";
  }
};

function addImport(program, importToAdd) {
  var importStatementCount = program.find(j.ImportDeclaration).length;

  if (importStatementCount === 0) {
    program.find(j.Statement).at(0).insertBefore(importToAdd);
    return program;
  }

  program.find(j.ImportDeclaration).forEach(function (stmt, idx) {
    if (idx === importStatementCount - 1) {
      stmt.replace(stmt.node, importToAdd);
    }
  });
  return program;
}

function findModuleExportsExpressions(program) {
  return program.find(j.AssignmentExpression).filter(function (path) {
    var _path$value = path.value,
        left = _path$value.left,
        right = _path$value.right;
    return left.type === "MemberExpression" && left.object.type === "Identifier" && left.property.type === "Identifier" && left.property.name === "exports" && right.type === "ObjectExpression";
  });
}

function addBabelPlugin(program, plugin) {
  findModuleExportsExpressions(program).forEach(function (moduleExportsExpression) {
    j(moduleExportsExpression).find(j.ObjectProperty, {
      key: {
        name: "plugins"
      }
    }).forEach(function (plugins) {
      var pluginExpression = Array.isArray(plugin) ? j.arrayExpression([j.literal(plugin[0]), j.objectExpression(Object.entries(plugin[1]).map(function (_ref) {
        var key = _ref[0],
            value = _ref[1];
        return j.objectProperty(j.identifier(key), j.literal(value));
      }))]) : j.literal(plugin);

      if (plugins.node.value.type === "ArrayExpression") {
        // TODO: detect if the plugin is already added
        plugins.node.value.elements.push(pluginExpression);
      }
    });
  });
  return program;
}

function addPrismaGenerator(program, generatorName, generatorBody) {
  if (program.includes("generator " + generatorName + " {")) return program;
  var prismaGenerator = ("\ngenerator " + generatorName + " {\n  " + generatorBody + "\n}").trim(); // Find the first generator and insert this entry there, otherwise at the top of the file.

  var index = Math.max(program.indexOf("generator "), 0);
  return [program.slice(0, index), prismaGenerator, program.slice(index)].join("\n");
}

export { type$2 as AddDependencyType, type$1 as FileTransformType, Frontmatter, type as NewFileType, RecipeBuilder, RecipeExecutor, addBabelPlugin, addImport, addPrismaGenerator, customTsParser, findModuleExportsExpressions, getExecutorArgument, paths };
